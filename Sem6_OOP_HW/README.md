## Объектно-ориентированное программирование (семинары)
### Урок 5. От простого к практике
**Задание:**
Создать калькулятор для работы с рациональными и комплексными числами, 
организовать меню, добавив в неё систему логирования.

Результат задания семинара 5 по ссылке https://github.com/julemalysheva/Java_introduction/tree/main/Sem5_OOP

### Урок 6. ООП Дизайн и Solid
**Задание:**
Рефакторинг и\или оптимизация проекта предыдущего дз
с учетом теоретических основ SOLID’а

### Доработки текущего проекта/пакета по заданию 6 семинара:

1. Проект дополнен документацией к классам и методам.
2. Изменена логика моделей расчетов. Во исполнение 1 и 2 принципа Solid выделены отдельные
компоненты на каждую операцию в пакете Рациональных и Комплексных расчетных моделей.
При необходимости расширений не придется их изменять, но можно будет дополнить,
доработав немного компоненту управления связями presenter.
3. Все классы соответствуют 3 и 4 принципу: реализуют ту же логику, 
что и классы-родители и/или применяют поведение интерфейсов, которые они реализуют.
4. С целью ослабления зависимостей от деталей по 5му принципу переделана логика
компоненты управления связями. Сейчас есть интерфейс I__Presenter, описывающий стандартное
поведение, абстрактный класс PresenterCalc, его расширяющий, дополняет компоненту полями
   View и Model.
Детали реализованы в дочерних классах по типу данных:
- PresenterComplex при выборе пользоватлем операций с комплексными числами
- PresenterRational при выборе пользователем операций с рациональными числами

В клиентском коде класса App presenter определяется методом setPresenter в зависимости
от выбора и помещается в переменную интерфейса I__Presenter. И неважно какой там конкретно
класс - наследник, метод buttonClick отработает с любым. В связи с этим возможно расширение
при необходимости - аналогично создается др. класс-наследник со своей логикой.
5. Изменен порядок работы с классом App. Из класса со статическими методами и полями он превратился
в обычный класс, для работы с которым при запуске нужно создать экземпляр App. Сделано
это для того, чтоб иметь возможность передать в конструктор тип пользовательского интерфейса и
и не иметь сильную связь. Принцип инверсии зависимостей: экз-р App при создании может принять любой тип View при необходимости,
   и не ограничиваться ConsoleView, что облегчит расширяемость.
К тому же App сейчас польностью работает через view, никакого сканера или печати в консоль
напрямую нет.